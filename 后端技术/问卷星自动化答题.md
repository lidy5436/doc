# 基于python实现问卷星自动填写脚本

闲来无事，突发奇想，想着做一个问卷调查的的自动化脚本。因此做了个简易版的python自动提交问卷星的脚本。希望给观看本文章的各位有所帮助。同时因为是简易版的自动填写问卷的脚本，所以还请各位大佬提出自己宝贵的意见，以供我们更好的优化。遇到问题也可以给我留言，我看到后会第一时间进行解答，郑重说明：代码仅提供学习之用，不提供任何商业用途。代码已上传至github，请根据自己的需要自取。

## 环境准备

在开始之前我们先要进行一些必要的配置。下载google自动化工具。首先查看自己浏览器的版本号。我以google浏览器为例。

![](./img/20240426001.png)

之后下载对应的 chromeDriver 版本，如果是最新版浏览器，直接通过以下链接下载即可。

```
https://googlechromelabs.github.io/chrome-for-testing/
```

![](./img/20240426002.png)

如果不是最新版浏览器，通过以下链接查找自己浏览器的版本下载即可

```
http://chromedriver.storage.googleapis.com/index.html
```

我建议还是使用最新版即可。

下载完后后会得到一个 chromedriver.exe 文件，我们需要将他复制到python安装路径的Scripts文件夹里面，(我看网上有人说给 chromedriver.exe配置环境变量也可以，我没有试过，感兴趣的小伙伴可以去试试)。我这里的python安装路径如下，自己根据自己的安装路径配置。

```
C:\Users\lidy\AppData\Local\Programs\Python\Python37\Scripts
```

![](./img/20240426003.png)

接下来就是代码环境的配置。在代码中我主要用到了 `requests, numpy, selenium` 三个包，统一使用最新版本。我将对应的版本号为

```
selenium==4.11.2
requests==2.31.0
numpy==1.21.6
```

小伙伴们可以通过 `pip install [包名]` 进行下载。下载完成后。准备工作结束。

## 代码实现

针对问卷调查的几种常用题题目，我进行了函数封装。核心代码如下。

```python
# 填空题
def vacantQuestion(driver, current):
    context = texts.get(str(current))
    prob = textsProb.get(str(current))
    prob = [x / sum(prob) for x in prob]
    textIndex = numpy.random.choice(a=numpy.arange(0, len(prob)), p=prob)
    driver.find_element(By.CSS_SELECTOR, f'#q{current}').send_keys(context[textIndex])


# 单选题
def singleQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/div[2]/div'
    options = driver.find_elements(By.XPATH, xpath)
    prob = singleProb.get(str(current))
    if prob is None:
        option = random.randint(1, len(options))
    else:
        if len(prob) != len(options):
            print(f"第{current}题参数数量：{len(prob)},选项数量{len(options)},不一致！")
            return
        prob = [x / sum(prob) for x in prob]
        option = numpy.random.choice(a=numpy.arange(1, len(options) + 1), p=prob)
    driver.find_element(By.CSS_SELECTOR,
                        f'#div{current} > div.ui-controlgroup > div:nth-child({option})').click()


# 多选题
def multipleQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/div[2]/div'
    options = driver.find_elements(By.XPATH, xpath)
    multipleList = []
    prob = multipleProb.get(str(current))
    if len(options) != len(prob):
        print(f"第{current}题概率值和选项值不一致")
        return
        # 生成序列，同时保证至少有一个
    while sum(multipleList) <= 1:
        multipleList = []
        for item in prob:
            option = numpy.random.choice(a=numpy.arange(0, 2), p=[1 - (item / 100), item / 100])
            multipleList.append(option)
    # 依次点击
    for (index, item) in enumerate(multipleList):
        if item == 1:
            css = f"#div{current} > div.ui-controlgroup > div:nth-child({index + 1})"
            driver.find_element(By.CSS_SELECTOR, css).click()


# 量表题
def scaleQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/div[2]/div/ul/li'
    options = driver.find_elements(By.XPATH, xpath)
    prob = scaleProb.get(str(current))
    if prob is None:
        option = random.randint(1, len(options))
    else:
        prob = [x / sum(prob) for x in prob]
        option = numpy.random.choice(a=numpy.arange(1, len(options) + 1), p=prob)
    driver.find_element(By.CSS_SELECTOR,
                        f"#div{current} > div.scale-div > div > ul > li:nth-child({option})").click()


# 下拉选择题
def dropDownQuestion(driver, current):
    # 先点击 '请选择'
    driver.find_element(By.CSS_SELECTOR, f"#select2-q{current}-container").click()
    time.sleep(0.5)
    # 选项数量
    options = driver.find_elements(By.XPATH, f"//*[@id='select2-q{current}-results']/li")
    prob = dropDownProb.get(str(current))
    prob = [x / sum(prob) for x in prob]
    option = numpy.random.choice(a=numpy.arange(1, len(options)), p=prob)
    driver.find_element(By.XPATH, f"//*[@id='select2-q{current}-results']/li[{option + 1}]").click()


# 滑块题
def sliderQuestion(driver, current):
    scope = random.randint(1, 100)
    driver.find_element(By.CSS_SELECTOR, f'#q{current}').send_keys(scope)


# 排序题
def orderQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/ul/li'
    options = driver.find_elements(By.XPATH, xpath)
    for i in range(1, len(options) + 1):
        option = random.randint(i, len(options))
        driver.find_element(By.CSS_SELECTOR, f'#div{current} > ul > li:nth-child({option})').click()
        time.sleep(0.4)
```

主逻辑的实现核心代码如下

```python
# 检测题量和页数
# 返回结果: 数组 ['第一页题数','第二页题数','第三页题数',...]
def selectQuestionNumAndPage(driver):
    questionList = []
    xpath = '//*[@id="divQuestion"]/fieldset'
    # 页数
    pageNum = len(driver.find_elements(By.XPATH, xpath))
    # 每一页的题
    questions = driver.find_elements(By.XPATH, f'//*[@id="fieldset1"]/div')
    # 无效问题数量
    invalidQuestionNum = 0
    for item in questions:
        if item.get_attribute('topic').isdigit() is False:
            invalidQuestionNum += 1
    # 如果只有一页
    questionList.append(len(questions) - invalidQuestionNum)
    if pageNum >= 2:
        for i in range(2, pageNum + 1):
            questions = driver.find_elements(By.XPATH, f'//*[@id="fieldset{i}"]/div')
            invalidQuestionNum = 0
            for item in questions:
                if item.get_attribute('topic').isdigit() is False:
                    invalidQuestionNum += 1
            questionList.append(len(questions) - invalidQuestionNum)
    return questionList


# 刷题逻辑函数
def findAnswers(driver, answer):
    # 获取必要参数
    global texts, textsProb, singleProb, multipleProb, scaleProb, dropDownProb
    texts = answer.get('texts')
    textsProb = answer.get('textsProb')
    singleProb = answer.get('singleProb')
    multipleProb = answer.get('multipleProb')
    scaleProb = answer.get('scaleProb')
    dropDownProb = answer.get('dropDownProb')

    # 获取题目数量
    questionNumList = selectQuestionNumAndPage(driver)
    # 题号
    current = 0
    # 遍历每一页
    for pageNum in questionNumList:
        # 遍历每一道题
        for questionNum in range(1, pageNum + 1):
            current += 1
            # 确定题型
            questionType = driver.find_element(By.CSS_SELECTOR, f'#div{current}').get_attribute('type')
            if questionType == '1' or questionType == '2':
                # 单选题
                vacantQuestion(driver, current)
            elif questionType == '3':
                # 单选题
                singleQuestion(driver, current)
            elif questionType == '4':
                # 多选题
                multipleQuestion(driver, current)
            elif questionType == '5':
                # 量表题
                scaleQuestion(driver, current)
            elif questionType == '6':
                # 矩阵题
                pass
            elif questionType == '7':
                dropDownQuestion(driver, current)
            elif questionType == '8':
                # 滑块题
                sliderQuestion(driver, current)
            elif questionType == '9':
                # 排序题
                orderQuestion(driver, current)
            else:
                print(f"第{questionNum}题为不支持题型！")
        time.sleep(0.5)
        # 点击下一页
        try:
            driver.find_element(By.CSS_SELECTOR, '#divNext').click()
            time.sleep(0.5)
        except:
            # 点击提交
            driver.find_element(By.XPATH, '//*[@id="ctlNext"]').click()
    submitQuestion(driver)


# 提交问卷
def submitQuestion(driver):
    time.sleep(1)
    # 点击对话框的确认按钮
    try:
        driver.find_element(By.XPATH, '//*[@id="layui-layer1"]/div[3]/a').click()
        time.sleep(1)
    except:
        pass
    # 点击智能检测按钮
    try:
        driver.find_element(By.XPATH, '//*[@id="SM_BTN_1"]').click()
        time.sleep(1)
    except:
        pass
    # 滑块验证
    try:
        slider = driver.find_element(By.XPATH, '//*[@id="nc_1__scale_text"]/span')
        if str(slider.text).startswith('请按住滑块'):
            width = slider.size.get('width')
            ActionChains(driver).drag_and_drop_by_offset(slider, width, 0).perform()
    except:
        pass
```

## 完整代码

首先目录结构如图所示。

![](./img/20240426004.png)

main.py 

```python
import time

from selenium import webdriver
import question

# 问卷星地址
url = 'https://www.wjx.cn/vm/????.aspx#'
# 填空题参数
question.texts = {'3': ['选A', '选B', '选C']}
# 填空题概率参数
question.textsProb = {'3': [1, 1, 1]}
# 单选题参数
question.singleProb = {'1': [1, 1, 1, 1]}
# 量表题概率参数
question.scaleProb = {'4': [1, 1, 1, 1, 1]}
# 下拉框概率
question.dropDownProb = {'5': [1, 1]}

# 答案
answer = {
    # 填空题参数
    "texts": {'3': ['选A', '选B', '选C']},
    # 填空题概率参数
    "textsProb": {'3': [1, 1, 1]},
    # 单选题参数
    "singleProb": {'1': [1, 1, 1, 1]},
    # 多选题参数
    "multipleProb": {'2': [100, 25, 50, 40]},
    # 量表题概率参数
    "scaleProb": {'4': [1, 1, 1, 1, 1]},
    # 下拉框概率
    "dropDownProb": {'5': [1, 1]}
}


# 获取本地IP地址
def getLocationIpAddress():
    return '127.0.0.1'


def runRequest():
    for i in range(5):
        # 躲避智能检测，将网页中的window.navigator中的webdriver设置为false
        option = webdriver.ChromeOptions()
        option.add_experimental_option('excludeSwitches', ['enable-automation'])
        option.add_experimental_option('useAutomationExtension', False)
        driver = webdriver.Chrome(options=option)
        driver.execute_cdp_cmd('Page.addScriptToEvaluateOnNewDocument',
                               {'source': 'Object.defineProperty(navigator, "webdriver", {get:()=>undefined});'
                                })
        # 设置浏览器的大小和位置
        driver.set_window_size(600, 500)
        driver.set_window_position(x=400, y=50)
        # 访问地址
        driver.get(url)
        # 刷题主逻辑
        question.findAnswers(driver, answer)
        time.sleep(2)
        driver.quit()
        print(f'第{i + 1}份填写完成')


if __name__ == "__main__":
    runRequest()

```

question.py

```python
import random
import time

import numpy.random
from selenium.webdriver import ActionChains
from selenium.webdriver.common.by import By

# 填空题参数
texts = {}
# 填空题概率参数
textsProb = {}
# 单选题参数
singleProb = {}
# 多选题参数
multipleProb = {}
# 量表题概率参数
scaleProb = {}
# 下拉框概率
dropDownProb = {}


# 检测题量和页数
# 返回结果: 数组 ['第一页题数','第二页题数','第三页题数',...]
def selectQuestionNumAndPage(driver):
    questionList = []
    xpath = '//*[@id="divQuestion"]/fieldset'
    # 页数
    pageNum = len(driver.find_elements(By.XPATH, xpath))
    # 每一页的题
    questions = driver.find_elements(By.XPATH, f'//*[@id="fieldset1"]/div')
    # 无效问题数量
    invalidQuestionNum = 0
    for item in questions:
        if item.get_attribute('topic').isdigit() is False:
            invalidQuestionNum += 1
    # 如果只有一页
    questionList.append(len(questions) - invalidQuestionNum)
    if pageNum >= 2:
        for i in range(2, pageNum + 1):
            questions = driver.find_elements(By.XPATH, f'//*[@id="fieldset{i}"]/div')
            invalidQuestionNum = 0
            for item in questions:
                if item.get_attribute('topic').isdigit() is False:
                    invalidQuestionNum += 1
            questionList.append(len(questions) - invalidQuestionNum)
    return questionList


# 刷题逻辑函数
def findAnswers(driver, answer):
    # 获取必要参数
    global texts, textsProb, singleProb, multipleProb, scaleProb, dropDownProb
    texts = answer.get('texts')
    textsProb = answer.get('textsProb')
    singleProb = answer.get('singleProb')
    multipleProb = answer.get('multipleProb')
    scaleProb = answer.get('scaleProb')
    dropDownProb = answer.get('dropDownProb')

    # 获取题目数量
    questionNumList = selectQuestionNumAndPage(driver)
    # 题号
    current = 0
    # 遍历每一页
    for pageNum in questionNumList:
        # 遍历每一道题
        for questionNum in range(1, pageNum + 1):
            current += 1
            # 确定题型
            questionType = driver.find_element(By.CSS_SELECTOR, f'#div{current}').get_attribute('type')
            if questionType == '1' or questionType == '2':
                # 单选题
                vacantQuestion(driver, current)
            elif questionType == '3':
                # 单选题
                singleQuestion(driver, current)
            elif questionType == '4':
                # 多选题
                multipleQuestion(driver, current)
            elif questionType == '5':
                # 量表题
                scaleQuestion(driver, current)
            elif questionType == '6':
                # 矩阵题
                pass
            elif questionType == '7':
                dropDownQuestion(driver, current)
            elif questionType == '8':
                # 滑块题
                sliderQuestion(driver, current)
            elif questionType == '9':
                # 排序题
                orderQuestion(driver, current)
            else:
                print(f"第{questionNum}题为不支持题型！")
        time.sleep(0.5)
        # 点击下一页
        try:
            driver.find_element(By.CSS_SELECTOR, '#divNext').click()
            time.sleep(0.5)
        except:
            # 点击提交
            driver.find_element(By.XPATH, '//*[@id="ctlNext"]').click()
    submitQuestion(driver)


# 提交问卷
def submitQuestion(driver):
    time.sleep(1)
    # 点击对话框的确认按钮
    try:
        driver.find_element(By.XPATH, '//*[@id="layui-layer1"]/div[3]/a').click()
        time.sleep(1)
    except:
        pass
    # 点击智能检测按钮
    try:
        driver.find_element(By.XPATH, '//*[@id="SM_BTN_1"]').click()
        time.sleep(1)
    except:
        pass
    # 滑块验证
    try:
        slider = driver.find_element(By.XPATH, '//*[@id="nc_1__scale_text"]/span')
        if str(slider.text).startswith('请按住滑块'):
            width = slider.size.get('width')
            ActionChains(driver).drag_and_drop_by_offset(slider, width, 0).perform()
    except:
        pass


# 填空题
def vacantQuestion(driver, current):
    context = texts.get(str(current))
    prob = textsProb.get(str(current))
    prob = [x / sum(prob) for x in prob]
    textIndex = numpy.random.choice(a=numpy.arange(0, len(prob)), p=prob)
    driver.find_element(By.CSS_SELECTOR, f'#q{current}').send_keys(context[textIndex])


# 单选题
def singleQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/div[2]/div'
    options = driver.find_elements(By.XPATH, xpath)
    prob = singleProb.get(str(current))
    if prob is None:
        option = random.randint(1, len(options))
    else:
        if len(prob) != len(options):
            print(f"第{current}题参数数量：{len(prob)},选项数量{len(options)},不一致！")
            return
        prob = [x / sum(prob) for x in prob]
        option = numpy.random.choice(a=numpy.arange(1, len(options) + 1), p=prob)
    driver.find_element(By.CSS_SELECTOR,
                        f'#div{current} > div.ui-controlgroup > div:nth-child({option})').click()


# 多选题
def multipleQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/div[2]/div'
    options = driver.find_elements(By.XPATH, xpath)
    multipleList = []
    prob = multipleProb.get(str(current))
    if len(options) != len(prob):
        print(f"第{current}题概率值和选项值不一致")
        return
        # 生成序列，同时保证至少有一个
    while sum(multipleList) <= 1:
        multipleList = []
        for item in prob:
            option = numpy.random.choice(a=numpy.arange(0, 2), p=[1 - (item / 100), item / 100])
            multipleList.append(option)
    # 依次点击
    for (index, item) in enumerate(multipleList):
        if item == 1:
            css = f"#div{current} > div.ui-controlgroup > div:nth-child({index + 1})"
            driver.find_element(By.CSS_SELECTOR, css).click()


# 量表题
def scaleQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/div[2]/div/ul/li'
    options = driver.find_elements(By.XPATH, xpath)
    prob = scaleProb.get(str(current))
    if prob is None:
        option = random.randint(1, len(options))
    else:
        prob = [x / sum(prob) for x in prob]
        option = numpy.random.choice(a=numpy.arange(1, len(options) + 1), p=prob)
    driver.find_element(By.CSS_SELECTOR,
                        f"#div{current} > div.scale-div > div > ul > li:nth-child({option})").click()


# 下拉选择题
def dropDownQuestion(driver, current):
    # 先点击 '请选择'
    driver.find_element(By.CSS_SELECTOR, f"#select2-q{current}-container").click()
    time.sleep(0.5)
    # 选项数量
    options = driver.find_elements(By.XPATH, f"//*[@id='select2-q{current}-results']/li")
    prob = dropDownProb.get(str(current))
    prob = [x / sum(prob) for x in prob]
    option = numpy.random.choice(a=numpy.arange(1, len(options)), p=prob)
    driver.find_element(By.XPATH, f"//*[@id='select2-q{current}-results']/li[{option + 1}]").click()


# 滑块题
def sliderQuestion(driver, current):
    scope = random.randint(1, 100)
    driver.find_element(By.CSS_SELECTOR, f'#q{current}').send_keys(scope)


# 排序题
def orderQuestion(driver, current):
    xpath = f'//*[@id="div{current}"]/ul/li'
    options = driver.find_elements(By.XPATH, xpath)
    for i in range(1, len(options) + 1):
        option = random.randint(i, len(options))
        driver.find_element(By.CSS_SELECTOR, f'#div{current} > ul > li:nth-child({option})').click()
        time.sleep(0.4)

```

完整代码下载请访问Github,

地址为:https://github.com/lidy5436/CaseCode/blob/master/%E9%97%AE%E5%8D%B7%E6%98%9F%E8%87%AA%E5%8A%A8%E5%8C%96/main.py